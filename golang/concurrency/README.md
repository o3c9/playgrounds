# Concurrency in Go

By Katherine Cox-Buday

## Chapter 1. An Introduction to Concurrency

Concurrency = 並行 => マルチタスキングのこと（シングルコアで切り替えながら同時に進める）
Parallel = 並列 => 同時に複数のコア・スレッドを処理を行うこと

### 問題点

1. Race Conditions

読み書きの順序の整合性が取れていない場合に，２つの処理どうしで互いにデータを取り合ってしまう

1. Atomicity

これ以上分割できない単位の処理であること．Atomicityは，「どんなcontextにおいて」ということとセットで考える．
Requestの単位，Processの単位，OSの単位など，スコープによって，Atomicかどうかは変わる．
なぜこれが重要なのかというと，Atomicな操作はConcurrentな処理においても安全だから．
大抵の処理はatomicじゃないので，いろんなテクニックをつかって，Atomicにさせる必要がある

1. Memory Access Synchronization

同時に複数の処理から同一メモリにアクセスさせることがないように，Mutexを利用して，Lockをかけて，アクセスをsynchronizedにする．
しかし，同期アクセスを常に強要するのはパフォーマンスに難がある．

1. Deadlocks, Livelocks, and Starvation

- Deadlock: 複数の処理が互いに相手が終わるのを待ち続ける
- Livelock: 並行処理が走っているが，全体の進捗が全くない状態
  - 自転車がすれ違うときに，互いに同じ方向に避けあって，また反対に行ってを繰り返すような状態
  - Starvationの一種である
- Starvation: 並行処理に必要なリソースを確保できなくて，タスクを完了できないこと
  - GreedyなプロセスがLockを持ち続けすぎていて，他の処理の邪魔をしているような場合に起こる

### 並列実行の安全性を見極める

これがもっとも難しい．ある関数のシグネチャだけをみて，

```
// CalculatePi calculates digits of Pi between the begin and end place.
func CalculatePi(begin, end int64, pi *Pi)
```

- で，この関数をどうcallすればいいの？
- 利用する側が，複数の並列実行処理を書くべきなの？
- 利用する側が渡した変数に複数のインスタンスからアクセスがあるみたいだけど，同期処理は自分でやるべき？それともこの関数内でやってくれるの？

これらの疑問について，コメントで明確にしておくのが大切

- 並列実行に責任を持つのは誰か？
- 解こうとしている問題でどのように並列処理が利用されているのか？
- データの同期に責任を持つのは誰か？

Goは，言語デザインからこういった問題に対して適切にアプローチしている．一番ややこしいところはgoのruntimeが担ってくれているので，自分たちは
goが提供するやり方に従えば良い．

たとえばHTTPサーバーをつくるときに，ある言語では，コネクションを受け取るためのThread Poolを事前につくっておき，そのスレッドをLoopさせて，リクエストを処理させるような仕組みになっている．
しかし，goでは，関数の前に`go`キーワードを書くだけで，あとは勝手にやってくれる



